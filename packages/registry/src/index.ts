/**
 * AgentCN Registry API
 * Cloudflare Worker serving package metadata from GitHub
 */

import { Hono } from "hono"
import { cors } from "hono/cors"

// CloudflareBindings is auto-generated by `wrangler types`
// Run `bun run cf-typegen` to generate worker-configuration.d.ts

const app = new Hono<{ Bindings: CloudflareBindings }>()

// Enable CORS for all routes
app.use("*", cors())

// Cache duration in seconds (1 hour)
const CACHE_TTL = 3600

/**
 * Fetch file from GitHub with caching
 */
async function fetchFromGitHub(
	env: CloudflareBindings,
	path: string,
	ctx: ExecutionContext,
): Promise<Response | null> {
	const url = `https://raw.githubusercontent.com/${env.GITHUB_OWNER}/${env.GITHUB_REPO}/${env.GITHUB_BRANCH}/${path}`

	// Check cache first
	const cache = caches.default
	const cacheKey = new Request(url)
	let response = await cache.match(cacheKey)

	if (response) {
		return response
	}

	// Fetch from GitHub
	const githubResponse = await fetch(url)

	if (!githubResponse.ok) {
		return null
	}

	// Clone and cache the response
	response = new Response(githubResponse.body, {
		headers: {
			"Content-Type": "application/json",
			"Cache-Control": `public, max-age=${CACHE_TTL}`,
			"Access-Control-Allow-Origin": "*",
		},
	})

	// Store in cache (non-blocking)
	ctx.waitUntil(cache.put(cacheKey, response.clone()))

	return response
}

/**
 * Health check
 */
app.get("/", (c) => {
	return c.json({
		name: "AgentCN Registry",
		version: "0.1.0",
		docs: "https://agentcn.dev/docs",
	})
})

/**
 * Get registry index (list of all packages)
 */
app.get("/r/index.json", async (c) => {
	const response = await fetchFromGitHub(c.env, "registry/index.json", c.executionCtx)

	if (!response) {
		return c.json({ error: "Failed to fetch registry index" }, 500)
	}

	return response
})

/**
 * Get package metadata and files
 */
app.get("/r/:name.json", async (c) => {
	const name = c.req.param("name")
	const response = await fetchFromGitHub(
		c.env,
		`registry/packages/${name}/package.json`,
		c.executionCtx,
	)

	if (!response) {
		return c.json(
			{
				error: "Package not found",
				package: name,
			},
			404,
		)
	}

	return response
})

/**
 * Get package file content
 */
app.get("/r/:name/files/*", async (c) => {
	const name = c.req.param("name")
	const filePath = c.req.path.replace(`/r/${name}/files/`, "")

	const response = await fetchFromGitHub(
		c.env,
		`registry/packages/${name}/${filePath}`,
		c.executionCtx,
	)

	if (!response) {
		return c.json(
			{
				error: "File not found",
				package: name,
				file: filePath,
			},
			404,
		)
	}

	// Determine content type based on extension
	const ext = filePath.split(".").pop()
	const contentTypes: Record<string, string> = {
		ts: "text/typescript",
		js: "text/javascript",
		md: "text/markdown",
		json: "application/json",
	}

	return new Response(response.body, {
		headers: {
			"Content-Type": contentTypes[ext ?? ""] ?? "text/plain",
			"Cache-Control": `public, max-age=${CACHE_TTL}`,
			"Access-Control-Allow-Origin": "*",
		},
	})
})

/**
 * Search packages
 */
app.get("/r/search", async (c) => {
	const query = c.req.query("q")?.toLowerCase() ?? ""

	// Fetch the index
	const response = await fetchFromGitHub(c.env, "registry/index.json", c.executionCtx)

	if (!response) {
		return c.json({ error: "Failed to fetch registry index" }, 500)
	}

	const index = (await response.clone().json()) as {
		packages: Array<{ name: string; description?: string; type: string }>
	}

	// Filter packages by query
	const results = index.packages.filter(
		(pkg) =>
			pkg.name.toLowerCase().includes(query) || pkg.description?.toLowerCase().includes(query),
	)

	return c.json({ query, results })
})

/**
 * Webhook for cache invalidation (called by GitHub Actions on release)
 */
app.post("/webhook/invalidate", async (c) => {
	// In production, verify webhook signature
	const cache = caches.default

	// Invalidate index
	const indexUrl = `https://raw.githubusercontent.com/${c.env.GITHUB_OWNER}/${c.env.GITHUB_REPO}/${c.env.GITHUB_BRANCH}/registry/index.json`
	await cache.delete(new Request(indexUrl))

	return c.json({ success: true, message: "Cache invalidated" })
})

export default app
